#!/usr/bin/env python3

"""Script to generate a bibfile from the Rubin documentation search service,
which is hosted by Algolia.

Note: The front-end for this documentation metadata is https://www.lsst.io. The
data is supplied by Ook, https://github.com/lsst-sqre/ook.
"""

import argparse
import asyncio
import calendar
import re
from datetime import UTC, datetime

import latexcodec  # noqa provides the latex+latin codec
import pybtex.database
import yaml
from algoliasearch.search.client import SearchClientSync, SearchResponse
from bibtools import BibDict, BibEntry
from pybtex.database import BibliographyData
from pylatexenc.latex2text import LatexNodes2Text
from pylatexenc.latexencode import unicode_to_latex

MAXREC = 2000


def latex2text(latex: str) -> str:
    """Convert a LaTeX string into a plain text string.

    Parameters
    ----------
    latex : `str`
        Latex string to convert.

    Returns
    -------
    plain : `str`
        The plain text version.
    """
    return LatexNodes2Text().latex_to_text(latex)


def isCommittee(author: str) -> bool:
    """Guess if this is a committee or working group paper.

    For DM-39724 decide if we have a non regular author
    for Committee and Working group papers we need to {} them
    This is a way to decide if we have a committee.
    """
    if "," in author:
        # assume if there is Author, A.N  it is regular
        return False
    authorl = author.lower()
    if "committee" in authorl:
        return True
    if "group" in authorl:
        return True
    words = author.split()
    # if there are 5 words its probably not a person
    # an alternative wll be to list explicit groups here.
    return len(words) > 5


def sort_by_handle(key: str) -> str:
    """Allow Document-11 to come before Document-8."""
    try:
        hdl, num = key.split("-")
    except ValueError:
        # Doesn't look like a handle so return it directly.
        return key
    num = num.lstrip("0")
    try:
        handle_number = int(num)
    except ValueError:
        # Not a number.
        return key
    return f"{hdl.upper()}-{handle_number:09d}"


async def generate_bibfile(
    query: str | None = "", external: list[str] | None = None, dois: dict[str, str] | None = None
) -> str:
    """
    Query ook for the list of entries.
    Only returning meta data needed for bib entries.

    Parameters
    ----------
    query : `str`
        Any word/query string you would put in lsst.io empty for all.
    external : `str`, optional
        External bib files to seed the results. They are merged together in
        order (the final one takes priority) and then the results from
        the query are copied in, over-writing any previous entries.
    dois : `dict`, optional
        Mapping of a document handle to DOI.
        This is a temporary way of adding in a DOI into the bib entry until
        the DOI is part of the central data model.

    Returns
    -------
    result : `str`
        Formatted bib file string ready to be printed.
    """
    if not query:
        query = ""  # Algolia take None as string literal None

    client = SearchClientSync(app_id="0OJETYIVL5", api_key="b7bd2f1080a5c4fe5eee502462bcc9d3")
    res = client.search_single_index(
        index_name="document_dev",
        search_params={
            "attributesToRetrieve": [
                "handle",
                "series",
                "h1",
                "baseUrl",
                "sourceUpdateTime",
                "sourceUpdateTimestamp",
                "authorNames",
            ],
            "hitsPerPage": MAXREC,
            "query": query,
        },
    )
    print(f"Total hits: {len(res.hits)}, Query:'{query}'")

    search_data = create_bibentries(res, dois)
    print(f"Got {len(res.hits)} records max:{MAXREC} produced {len(search_data.entries)} bibentries.")

    # Read the external files that will be merged with the search results.
    # Do not use a BilbiographyData because duplicate key overwriting is
    # not allowed. BibTeX is case insensitive so use a special
    # case-insensitive but case-preserving dict. This is needed else pybtex
    # will complain if it finds Document-123 and document-123 in the dict.
    all_data = BibDict()
    if external:
        for bibfile in external:
            with open(bibfile) as fd:
                this_bib = BibliographyData.from_string(fd.read(), "bibtex")
            all_data.update(this_bib.entries)

    # Overwrite the entries from the search.
    all_data.update(search_data.entries)

    # Rebuild the final bib collection with sorting.
    bibdata = BibliographyData(entries={k: all_data[k] for k in sorted(all_data, key=sort_by_handle)})

    result = """## DO NOT EDIT THIS FILE. It is generated from generateBibfile.py
## Add static entries in etc/static_entries.bib (or remove them if they clash.
## This files should contain ALL entries on www.lsst.io

"""
    result += bibdata.to_string("bibtex")

    # pybtex is currently broken such that it escapes escapes:
    # https://bitbucket.org/pybtex-devs/pybtex/issues/153/backslashes-accumulate-when-saving-loading
    # Remove all the escaped \ characters (and assume that no titles have
    # them).
    result = result.replace("\\\\", "\\")

    return result


def create_bibentries(res: SearchResponse, dois: dict[str, str] | None = None) -> BibliographyData:
    """Create the bibtex entries."""
    entries: dict[str, pybtex.database.Entry] = {}
    doimap = dois if dois else {}
    for hit in res.hits:
        d = hit.model_dump()
        if "series" in d.keys() and d["series"] == "TESTN":
            continue
        if len(d["authorNames"]) == 1 and isCommittee(d["authorNames"][0]):
            authors = f"{{{d['authorNames'][0]}}}"
        else:
            authors = " and ".join(d["authorNames"])
        dt = d["sourceUpdateTimestamp"]
        date = datetime.fromtimestamp(dt, UTC)
        month = calendar.month_abbr[date.month].lower()
        if "baseUrl" in d:
            url = d["baseUrl"]
        else:
            # Use ls.st as fallback since that works for docushare handles
            # in case those turn up.
            url = f"https://ls.st/{d['handle']}"
            print(f"{url} did not have baseUrl set")

        if d["handle"] == "DMTN-306":
            # Total parsing failure of the latex so we must provide the
            # values ourselves.
            authors = " and ".join(
                [
                    "Fabio Hernandez",
                    "Mark G. Beckett",
                    "Andrew Hanushevsky",
                    "Tim Jenness",
                    "Kian-Tat Lim",
                    "Peter Love",
                    "Timothy Noble",
                    "Stephen R. Pietrowicz",
                    "Wei Yang",
                ]
            )
        elif d["handle"] == "PSTN-051":
            authors = " and ".join(
                [
                    "R. Lynne Jones",
                    "Peter Yoachim",
                    "Željko Ivezić",
                    "Eric H. {Neilsen Jr.}",
                    "Tiago Ribeiro",
                ]
            )
        elif d["handle"] == "PSTN-053":
            authors = " and ".join(
                [
                    "Rubin's Survey Cadence Optimization Committee",
                    "Franz E. Bauer",
                    "Sarah Brough",
                    "Renée Hložek",
                    "Željko Ivezić",
                    "R. Lynne Jones",
                    "Mansi M. Kasliwal",
                    "Knut Olsen",
                    "Hiranya V. Peiris",
                    "Megan E. Schwamb",
                    "Daniel Scolnic",
                    "Colin T. Slater",
                    "Jay Strader",
                    "Peter Yoachim",
                ]
            )
        be = BibEntry(
            checkFixAuthAndComma(fixTexSS(authors)),
            fixTex(d["h1"]),
            month,
            d["handle"],
            date.year,
            url=url,
            publisher="NSF-DOE Vera C. Rubin Observatory",
            doi=doimap.get(d["handle"]),
        )
        entry = be.get_pybtex()
        entries[entry.key] = entry

    # Sort by key on creation since BibliographyData doesn't have
    # a sort method internally.
    return BibliographyData(entries={k: entries[k] for k in sorted(entries)})


def fixTex(text: str) -> str:
    """
    Escape special TeX chars.
    :param text:
    :return: modified text
    """
    specialChars = "_$&%^#"
    for c in specialChars:
        text = text.replace(c, f"\\{c}")
    return text


def checkFixAuthAndComma(authors: str) -> str:
    """Fix author lists.

    Some people used comma-separated author lists - bibtex does not like that.
    Here we replace the comma with and.
    And someone put an & in the author list - that is not allowed either.

    :param authors:
    :return: authors in and format
    """
    # Special case DMTN-085 which currently parses wrong because it uses
    # commas in the author names.
    if (
        authors == "Bellm and E.C. and Chiang and H.-F. and Fausti and A. and Krughoff and K.S. and MacArthur"
        " and L.A. and Morton and T.D. and Swinbank and J.D. (chair) and Roby and T."
    ):
        authors = (
            "E. C Bellm and H.-F. Chiang and A. Fausti and K. S. Krughoff and L. A. MacArthur "
            "and T. D. Morton and J. D. Swinbank and T. Roby"
        )

    if "," in authors:
        # a bit heavy handed but
        authors = authors.replace(",", " and")
    if "&" in authors:
        authors = authors.replace("&", " and")

    # This is now in bibtex form. In the absence of authorids we have to
    # now use heuristics to fix some authors who have two surnames without
    # a hyphen. pybtex makes some bad assumptions.
    authors = authors.removesuffix("et al.")

    authors = authors.strip()
    if not authors:
        return authors

    # System Integration Test and Commissioning Team is a single author
    authors = authors.replace("System Integration Test and Commissioning Team", "SITCOM")

    # Sometimes we have a "and and"
    authors = re.sub(r"and\s+and", "and", authors)

    # We do not want the oversight text in that one document.
    authors = authors.replace(
        "Agency oversight: Ashley Zauderer-Vanderley (NSF) and Helmut Marsiske (DOE)", ""
    )
    if not authors:
        raise RuntimeError("WTF")
    # Split on "and"
    author_list = re.split(r"\s+and\s+", authors)
    author_modified: list[str] = []
    for author in author_list:
        if author in ("on behalf of the Rubin Construction Project", "...."):
            continue
        if author == "SITCOM":
            author = "System Integration Test and Commissioning Team"
        for zero_out in (
            "_for the LSST Project_",
            "_for the LSST Data Management_",
            "on behalf of the Rubin Observatory Project Science Team",
            "(She/Her)",
            "(University of Washington)",
            "(LPNHE/IN2P3/CNRS Paris)",
            "(chair)",
            "on behalf of Science Pipelines Team",
            "other contributors",
        ):
            author = author.replace(zero_out, "")
        # In one case we get {} around the entire author string.
        # But we do not want to break latex escapes.
        if author.endswith(" }") and author.startswith("{G"):
            author = author.removeprefix("{")
            author = author.removesuffix("}")
        author = author.strip()
        author = author.removesuffix(" and")
        if author.lower() == "{On behalf of Rubin Observatory Project}".lower():
            author = "Vera C. Rubin Observatory"
        if (
            "Rubin Observatory" in author
            or "Team" in author
            or "Collaboration" in author
            or "Committee" in author
        ):
            # Organizational author. Need to quote the entire author.
            # Sometimes they start with "the" so capitalize the first.
            author = author[0].capitalize() + author[1:]
            author = "{" + author + "}"
        # Use unicode here, not latex.
        for known in (
            "Aracena Alcayaga",
            "Araya Cortes",
            "Constanzo Córdova",
            "da Costa",
            "de Peyster",
            "de Val-Borro",
            "Fausti Neto",
            "Fonseca Alvarez",
            "Garavito Camargo",
            "Giraldo Murillo",
            "Gomez Jimenez",
            "Le Boulc'h",
            "Le Guillou",
            "Lopez Toro",
            "Lorenzo Martinez",
            "Megias Homar",
            "Morales Marín",
            "Narayanan K",
            "Orellana Munoz",
            "Plazas Malagón",
            "Quintero Marin",
            "Ribeiro de Souza",
            "Rivera Rivera",
            "Rodrigues de Campos",
            "Sedaghat Alvar",
            "Sepulveda Valenzuela",
            "Sotuela Elorriaga",
            "Toribio San Cipriano",
            "Van Berg",
            "van Klaveren",
            "van Reeven",
            "van Velzen",
            "Vanden Berk",
            "Villicana Pedraza",
            "von der Linden",
        ):
            # Sphinx technotes can generate author names with braces around
            # unicode characters that are in a different form to those in the
            # latex author db. We need to normalize to unicode here and then
            # convert back to latex.
            bib_author = author
            if "\\" in bib_author:
                bib_author = latex2text(bib_author)
            if known.lower() in bib_author.lower():
                author = re.sub(re.escape(known), f"{{{known}}}", bib_author, flags=re.IGNORECASE)
                # Convert back to latex, which will escape the braces so we
                # need to unescape them.
                author = unicode_to_latex(author)
                author = author.replace("\\{", "{").replace("\\}", "}")
        author = author.strip()
        if author:
            author_modified.append(author)
    return " and ".join(author_modified)


def fixTexSS(text: str) -> str:
    """
    There are several UTF special chars in lsst.io which need to be TeXified.
    This routing catches them and replaces them with TeX versions (or nothing).
    :param text:
    :return: modified text
    """
    try:
        text.encode("ascii")
        # If three are no non ascii chars i have nothing to do !!
        # the encoding here is only to see if there are any UTF-8s
        # the result is not used.
    except UnicodeEncodeError:
        # Some of these came from RHL's HSC code - I do not understand them all
        for ci, co in [
            ("’", "'"),
            ("…", "..."),
            ("“", '"'),  # double quote unicode 8221 (LEFT)
            ("”", '"'),  # and 8220 (RIGHT) The may look the same
            ("´", "'"),
            (" ", " "),
            ("–", "-"),  # en-dash
            ("—", "-"),  # em-dash
            ("\U0010fc0e", "?"),  # '?' in a square
            ("？", "?"),
            ("à", "\\`{a}"),  # grave
            ("á", "\\'{a}"),  # acute
            ("â", "\\r{a}"),
            ("Ç", "\\c{C}"),
            ("ć", "\\'{c}"),
            ("ç", "\\c{c}"),
            ("ë", '\\"{e}'),
            ("é", "\\'{e}"),
            ("è", "\\`{e}"),
            ("ê", "\\r{e}"),
            ("¡", "i"),
            ("í", "\\'{i}"),
            ("ó", "\\'{o}"),
            ("ñ", "\\~{n}"),
            ("ö", '\\"{o}'),
            ("û", "\\r{u}"),
            ("ü", '\\"{u}'),
            ("ù", "\\`{u}"),
            ("ž", "{\\v z}"),
            ("Ž", "{\\v Z}"),
            ("􏰎", " "),
            ("ï", '\\"{i}'),  # really i dieresis
            ("ô", "\\r{o}"),
            ("‘", "'"),
            ("ʻ", "'"),
            ("¹", ""),
            ("²", ""),
            ("³", ""),
            ("²", ""),
            ("⁴", ""),
            ("⁵", ""),
            ("⁶", ""),
            ("⁷", ""),
            ("⁸", ""),
        ]:
            text = text.replace(ci, co)
    return text


if __name__ == "__main__":
    description = __doc__
    formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=description, formatter_class=formatter)

    parser.add_argument("bibfile", help="Name of file to output bib entries to", nargs="?")
    parser.add_argument("-q", "--query", help="""Query string (optional)""")
    parser.add_argument(
        "--external",
        help="""Reference bib to use to obtain bib entries that have disappeared.""",
        action="append",
        nargs="?",
    )
    parser.add_argument("--dois", help="File mapping handles to DOIs.", type=str)

    args = parser.parse_args()

    doimap: dict[str, str] | None = None
    if args.dois:
        with open(args.dois) as fh:
            doimap = yaml.safe_load(fh)

    result = asyncio.run(generate_bibfile(args.query, args.external, doimap))

    # pybtex has already added a new line so do not add an additional
    # new line when printing.
    if args.bibfile:
        with open(args.bibfile, "w") as outfile:
            print(result, file=outfile, end="")
    else:
        print(result, end="")
