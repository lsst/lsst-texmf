#!/usr/bin/env python3

"""This script generates a bibfile from the Rubin documentation search service,
which is hosted by Algolia.
Note: The front-end for this documentation metadata is https://www.lsst.io. The
data is supplied by Ook, https://github.com/lsst-sqre/ook.
"""

import argparse
from algoliasearch.search_client import SearchClient
from datetime import datetime
import sys
import calendar
import latexcodec  # noqa provides the latex+latin codec


MAXREC = 2000


def write_latex_bibentry(auth, title, year, month, handle, url, fd=sys.stdout):

    """ Write a bibentry for document info passed.
    This assumes its an lsst.io entry and constructs the url accordingly.
    Parameters
    ----------
    auth : `str``
        Author list ready for tex
    title : `str`
    year  : `str`
    month  : `str`
    handle  : `str`

    """

    all_series = {
        "DMTN": "Data Management Technical Note",
        "RTN": "Technical Note",
        "PSTN": "Project Science Technical Note",
        "SCTR": "Commissioning Technical Report",
        "SITCOMTN": "Commissioning Technical Note",
        "SMTN": "Simulations Team Technical Note",
        "SQR": "SQuaRE Technical Note",
        "DMTR": "Data Management Test Report",
        "LDM": "Data Management Controlled Document",
    }
    prefix, _ = handle.split("-", 1)
    series = all_series.get(prefix, "")

    print("@DocuShare{{{},".format(handle), file=fd)
    print("   author = {{{}}},".format(auth), file=fd)
    print('    title = "{{{}}}",'.format(title), file=fd)
    print("     year = {},".format(year), file=fd)
    print("    month = {},".format(month), file=fd)
    print("   handle = {{{}}},".format(handle), file=fd)
    print("     note = {{Vera C. Rubin Observatory {}}},".format(series),
          file=fd)
    print("      url = {{{}}} }}".format(url), file=fd)


def generate_bibfile(outfile, query=""):
    """
    Query ook for the list of entries.
    Only returning meta data needed for bib entries.

    :param outfile: File to write
    :param query: Any word/query string you would put in lsst.io empty for all
    :return: the file will be writed contianing the entries.
    """
    if query is None:
        query = ""  # Algolia take None as string literal None
    client = SearchClient.create('0OJETYIVL5', 'b7bd2f1080a5c4fe5eee502462bcc9d3')
    index = client.init_index('document_dev')

    params = {
        'attributesToRetrieve': [
            'handle',
            'series',
            'h1',
            'baseUrl',
            'sourceUpdateTime',
            'sourceUpdateTimestamp',
            'authorNames'
        ],
        'hitsPerPage': MAXREC
    }

    res = index.search(query, params)
    print(f"Total hits: {len(res['hits'])}, Query:'{query}'")

    print('## DO NOT EDIT THIS FILE. It is generated from generateBibfile.py\n'
          '## Add static entries in etc/static_entries.bib (or remove them if they clash.\n'
          '## This files should contain ALL entries on www.lsst.io', file=outfile)

    bcount = 0
    for count, d in enumerate(res['hits']):
        if 'series' in d.keys() and d['series'] == "TESTN":
            continue
        bcount = bcount + 1
        authors = " and ".join(d['authorNames'])
        dt = d['sourceUpdateTimestamp']
        date = datetime.fromtimestamp(dt)
        month = calendar.month_abbr[date.month].lower()
        write_latex_bibentry(checkFixAuthAndComma(fixTexSS(authors)), fixTex(d['h1']),
                             date.year, month, d['handle'], d['baseUrl'], outfile)
        print(file=outfile)

    print(f"Got {count} records max:{MAXREC} produced {bcount} bibentries to {outfile}")


def fixTex(text):
    """
    Escape special TeX chars.
    :param text:
    :return: modified text
    """
    specialChars = "_$&%^#"
    for c in specialChars:
        text = text.replace(c, f"\\{c}")
    return text


def checkFixAuthAndComma(authors):
    """
    Soem people used comm seperated author lists - bibtex does not like that.
    Here we replave tghe comm with and.
    :param authors:
    :return: authors in and format
    """
    if "," in authors:
        # a bit heavy handed but
        authors = authors.replace(",", " and")
    return authors


def fixTexSS(text):
    """
    There are several UTF special chars in lsst.io which need to be TeXified.
    This routing catches them and replaces them with TeX versions (or nothing).
    :param text:
    :return: modified text
    """
    try:
        text.encode('ascii')
        # If three are no non ascii chars i have nothing to do !!
        # the encoding here is only to see if there are any UTF-8s
        # the result is not used.
    except UnicodeEncodeError:
        # Some of these came from RHL's HSC code - I do not understand them all
        for ci, co in [('’', "'"),
                       ('…', '...'),
                       ('“', '"'),  # double quote unicode 8221 (LEFT)
                       ('”', '"'),  # and 8220 (RIGHT) The may look the same
                       ('´', "'"),
                       (' ', ' '),
                       ('–', '-'),  # en-dash
                       ('—', '-'),  # em-dash
                       ('\U0010fc0e', '?'),  # '?' in a square
                       ('？', '?'),
                       ('à', '\\`{a}'),  # grave
                       ('á', "\\'{a}"),  # acute
                       ('â', '\\r{a}'),
                       ('Ç', '\\c{C}'),
                       ('ć', "\\'{c}"),
                       ('ç', '\\c{c}'),
                       ('ë', '\\"{e}'),
                       ('é', "\\'{e}"),
                       ('è', "\\`{e}"),
                       ('ê', '\\r{e}'),
                       ('¡', 'i'),
                       ('í', "\\'{i}"),
                       ('ó', "\\'{o}"),
                       ('ñ', '\\~{n}'),
                       ('ö', '\\"{o}'),
                       ('û', '\\r{u}'),
                       ('ü', '\\"{u}'),
                       ('ù', "\\`{u}"),
                       ('ž', '{\\v z}'),
                       ('Ž', '{\\v Z}'),
                       ('􏰎', ' '),
                       ('ï', '\\"{i}'),  # really i dieresis
                       ('ô', '\\r{o}'),
                       ('‘', "'"),
                       ('ʻ', "'"),
                       ('¹', ''),
                       ('²', ''),
                       ('³', ''),
                       ('²', ''),
                       ('⁴', ''),
                       ('⁵', ''),
                       ('⁶', ''),
                       ('⁷', ''),
                       ('⁸', ''),
                       ]:
            text = text.replace(ci, co)
    return text


if __name__ == "__main__":
    description = __doc__
    formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=formatter)

    parser.add_argument('bibfile', help='Name of file to output bib entries to')
    parser.add_argument("-q", "--query", help="""Query string (optional)""")

    args = parser.parse_args()

    outfile = sys.stdout
    if args.bibfile:
        outfile = open(args.bibfile, 'w')

    generate_bibfile(outfile, args.query)
    outfile.close()
